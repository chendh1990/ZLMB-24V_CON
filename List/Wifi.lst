C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE WIFI
OBJECT MODULE PLACED IN .\Output\Wifi.obj
COMPILER INVOKED BY: D:\Program Files\Keil\C51\BIN\C51.EXE Source\Wifi.c BROWSE INCDIR(.\Include;.\Bsp) DEFINE(FOSC_1600
                    -00) DEBUG OBJECTEXTEND PRINT(.\List\Wifi.lst) TABS(2) OBJECT(.\Output\Wifi.obj)

line level    source

   1          #define __WIFI_C__
   2          #include "Wifi.h"
   3          #include "PacketQueue.h"
   4          #include "Common.h"
   5          #include "Uart.h"
   6          #include "Sys.h"
   7          #include "Peripheral.h"
   8          #include "Led.h"
   9          #include "Log.h"
  10          
  11          
  12          static WifiPacketCfg_t XDATA s_WifiPacketCfg;
  13          static Wifi_t XDATA s_Wifi;
  14            
  15          static DownloadCmd_t const XDATA s_DownloadCmd[] =
  16          {
  17            {DPID_SWITCH_1, DP_TYPE_BOOL},
  18            {DPID_SWITCH_2, DP_TYPE_BOOL},
  19          };
  20          
  21          static void WifiPacketInit(void);
  22          static uint8 GetDownloadCmdTotal(void);
  23          static unsigned char GetDowmloadDataPointIdIndex(uint8 dpid);
  24          static uint8 DownloadDataPointHandle(const uint8 XDATA *pVal, uint8 XDATA dpid, uint8 XDATA length);
  25          static uint8 OneDataPointHand(uint8 const XDATA* pDPVal);
  26          static void AllDataPointHand(void);
  27          static void BoolDataPointUpdate(uint8 XDATA *const pbuffer, uint8 XDATA dpid, uint8 XDATA value);
  28          static void AllDataUpdate(void);
  29          void WifiPacketHandle(void);
  30          static void HeatBeatCheck(void);
  31          static void ProductInfoUpdate(void);
  32          static void AllDataUpdate(void);
  33          static void SetTxPacketData(uint8 const* const src, uint8 XDATA length);
  34          static void SendTxPacketData(uint8 XDATA cmd);
  35          
  36          
  37          void WifiInit(void)
  38          {
  39   1        s_Wifi.CurrState = WIFI_SATE_UNKNOW;
  40   1        s_Wifi.BackState = WIFI_SATE_UNKNOW;
  41   1        s_Wifi.resetFlag = RESET_WIFI_SUCCESS;
  42   1        s_Wifi.setModeFlag = SET_WIFICONFIG_SUCCESS;
  43   1        WifiPacketInit();
  44   1      }
  45          /*****************************************************************************
  46          函数名称 : GetDownloadCmdTotal
  47          功能描述 : 获取所有dp命令总和
  48          输入参数 : 无
  49          返回参数 : 下发命令总和
  50          使用说明 : 
  51          *****************************************************************************/
  52          static uint8 GetDownloadCmdTotal(void)
  53          {
  54   1        return(sizeof(s_DownloadCmd) / sizeof(s_DownloadCmd[0]));
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 2   

  55   1      }
  56          
  57          /*****************************************************************************
  58          函数名称 : get_update_dpid_index
  59          功能描述 : 获取制定DPID在数组中的序号
  60          输入参数 : dpid:dpid
  61          返回参数 : index:dp序号
  62          *****************************************************************************/
  63          static uint8 GetDowmloadDataPointIdIndex(uint8 dpid)
  64          {
  65   1        uint8 index;
  66   1        uint8 total = GetDownloadCmdTotal();
  67   1        
  68   1        for(index = 0; index < total; index ++)
  69   1        {
  70   2          if(s_DownloadCmd[index].dp_id == dpid)
  71   2          {
  72   3            break;
  73   3          }
  74   2        }
  75   1        return index;
  76   1      }
  77          /*****************************************************************************
  78          函数名称 : dp_download_handle
  79          功能描述 : dp下发处理函数
  80          输入参数 : dpid:DP序号
  81                     value:dp数据缓冲区地址
  82                     length:dp数据长度
  83          返回参数 : 成功返回:SUCCESS/失败返回:ERRO
  84          使用说明 : 该函数用户不能修改
  85          *****************************************************************************/
  86          static uint8 DownloadDataPointHandle(const uint8 XDATA *pVal, uint8 XDATA dpid, uint8 XDATA length)
  87          {
  88   1        /*********************************
  89   1        当前函数处理可下发/可上报数据调用                    
  90   1        具体函数内需要实现下发数据处理
  91   1        完成用需要将处理结果反馈至APP端,否则APP会认为下发失败
  92   1        ***********************************/
  93   1        MSG_t msg;
  94   1        if(!pVal)
  95   1        {
  96   2          return false;
  97   2        }
  98   1        length = length;
  99   1        msg.msgID = SYS_MSG_WINDOW_ID;
 100   1        switch(dpid)
 101   1        {
 102   2          case DPID_SWITCH_1:
 103   2            //开关处理函数
 104   2            if(pVal[0])
 105   2            {
 106   3              msg.Param = WINDOW_OPENING;
 107   3            }
 108   2            else
 109   2            {
 110   3              msg.Param = WINDOW_CLOSING;
 111   3            }
 112   2            QMsgPost(&g_QMsg, msg);
 113   2            break;
 114   2          case DPID_SWITCH_2:
 115   2            //暂停处理函数
 116   2            if(pVal[0])
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 3   

 117   2            {
 118   3              msg.Param = WINDOW_PAUSE;
 119   3              QMsgPost(&g_QMsg, msg);
 120   3            }
 121   2            break;
 122   2          default:
 123   2            break;
 124   2        }
 125   1        return true;
 126   1      }
 127          static void WifiPacketInit(void)
 128          {
 129   1        s_WifiPacketCfg.rxCnt = 0;
 130   1        s_WifiPacketCfg.rxStatus = RX_IDDLE;
 131   1        s_WifiPacketCfg.rxPack.head_0 = P_HEAD_0;
 132   1        s_WifiPacketCfg.rxPack.head_1 = P_HEAD_1;
 133   1        s_WifiPacketCfg.rxPack.ver = P_VER;
 134   1        
 135   1        s_WifiPacketCfg.txCnt = 0;
 136   1        s_WifiPacketCfg.txStatus = RX_IDDLE;
 137   1        s_WifiPacketCfg.txPack.head_0 = P_HEAD_0;
 138   1        s_WifiPacketCfg.txPack.head_1 = P_HEAD_1;
 139   1        s_WifiPacketCfg.txPack.ver = P_VER;
 140   1        s_WifiPacketCfg.txLength = 0;
 141   1      }
 142          void WifiPacketParse(void)
 143          {
 144   1          uint8 XDATA dat;
 145   1        uint8 XDATA checkSum;
 146   1        if(QueuePend(&dat) != 0)
 147   1        { 
 148   2          return ;
 149   2        }
 150   1      //  putchar(getHex(HI_UINT8(dat)));
 151   1      //  putchar(getHex(LO_UINT8(dat)));
 152   1      //  putchar(' ');
 153   1        switch(s_WifiPacketCfg.rxStatus)
 154   1        {
 155   2          case RX_IDDLE:
 156   2          {
 157   3            if(dat == P_HEAD_0)
 158   3            {
 159   4              s_WifiPacketCfg.rxStatus = RX_HEAD_0;
 160   4            }
 161   3            break;
 162   3          }
 163   2      
 164   2          case RX_HEAD_0:
 165   2          {
 166   3            if(dat == P_HEAD_1)
 167   3            {
 168   4              s_WifiPacketCfg.rxStatus = RX_HEAD_1;
 169   4            }
 170   3            else
 171   3            {
 172   4              s_WifiPacketCfg.rxStatus = RX_IDDLE;
 173   4            }
 174   3            break;
 175   3          } 
 176   2          case RX_HEAD_1:
 177   2          {
 178   3            if(dat == P_VER)
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 4   

 179   3            {
 180   4              s_WifiPacketCfg.rxStatus = RX_VER;
 181   4            }
 182   3            else
 183   3            {
 184   4              s_WifiPacketCfg.rxStatus = RX_IDDLE;
 185   4            }
 186   3            break;
 187   3          }
 188   2          case RX_VER:
 189   2          {
 190   3            s_WifiPacketCfg.rxPack.cmd = dat; //CMD
 191   3            s_WifiPacketCfg.rxStatus = RX_CMD;
 192   3            break;
 193   3          }
 194   2          case RX_CMD:
 195   2          {
 196   3            s_WifiPacketCfg.rxPack.length[0] = dat; //LENGTH0
 197   3            s_WifiPacketCfg.rxStatus = RX_LEN_0;
 198   3      
 199   3            break;
 200   3          }
 201   2          case RX_LEN_0:
 202   2          {
 203   3            s_WifiPacketCfg.rxPack.length[1] = dat; //LENGTH1
 204   3            s_WifiPacketCfg.rxLength = BUILD_UINT16(s_WifiPacketCfg.rxPack.length[1], s_WifiPacketCfg.rxPack.length
             -[0]);
 205   3            if(s_WifiPacketCfg.rxLength <= (UART_PACKET_DAT_MAX))
 206   3            {
 207   4              if(s_WifiPacketCfg.rxLength != 0)
 208   4              {
 209   5                s_WifiPacketCfg.rxStatus = RX_BUSY;
 210   5              }
 211   4              else
 212   4              {
 213   5                s_WifiPacketCfg.rxStatus = RX_VERIFY;
 214   5              }
 215   4            }
 216   3            else
 217   3            {
 218   4              s_WifiPacketCfg.rxStatus = RX_IDDLE;  
 219   4              s_WifiPacketCfg.rxCnt = 0;
 220   4              s_WifiPacketCfg.rxLength = 0;
 221   4            }
 222   3            break;
 223   3          }
 224   2          case RX_BUSY:
 225   2          {
 226   3          //  putchar('7');
 227   3          //  putchar('\r');
 228   3          //  putchar('\n');
 229   3            s_WifiPacketCfg.rxPack.dat[s_WifiPacketCfg.rxCnt++] = dat;
 230   3            if(s_WifiPacketCfg.rxCnt >= (s_WifiPacketCfg.rxLength))
 231   3            {
 232   4              s_WifiPacketCfg.rxStatus = RX_VERIFY;
 233   4            };
 234   3            break;
 235   3          }
 236   2          case RX_VERIFY:
 237   2          {
 238   3          //  putchar('8');
 239   3          //  putchar('\r');
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 5   

 240   3          //  putchar('\n');
 241   3          //  putchar(getHex(HI_UINT8(dat)));
 242   3          //  putchar(getHex(LO_UINT8(dat)));
 243   3          //  putchar('\r');
 244   3          //  putchar('\n');
 245   3      
 246   3            checkSum = getCheckSum((uint8  *)(&(s_WifiPacketCfg.rxPack.head_0)), s_WifiPacketCfg.rxCnt+6);
 247   3          //  checkSum = SUM_HEAD_VER;
 248   3            if(checkSum == dat)
 249   3            {
 250   4            //  uint8 XDATA s[] =  "+verify ok!\r\n";
 251   4              //  UartSendHexBuffer(UART_WIFI, "+results:", (uint8  *)(&(checkSum)), 1, ' ', true);
 252   4            //  UartSendString(UART_WIFI, s);
 253   4              WifiPacketHandle();
 254   4            //  UartSendHexBuffer(UART_WIFI, "+raw:", (uint8  *)(&(s_WifiPacketCfg.rxPack.cmd)), s_WifiPacketCfg.rxC
             -nt+3, ' ', true);
 255   4            
 256   4            }
 257   3            else
 258   3            {
 259   4            //  uint8 XDATA s[] =  "-verify fail!\r\n";
 260   4            //  UartSendHexBuffer(UART_WIFI, "-results:", (uint8  *)(&(checkSum)), 1, ' ', true);
 261   4            //  checkSum = s_WifiPacketCfg.rxPack.dat[0] + s_WifiPacketCfg.rxPack.dat[1] + s_WifiPacketCfg.rxPack.da
             -t[2];
 262   4            //  UartSendHexBuffer(UART_WIFI, "--results:", (uint8  *)(&(checkSum)), 1, ' ', true);
 263   4            //  UartSendString(UART_WIFI, s);
 264   4            //  UartSendHexBuffer(UART_WIFI, "-raw:", (uint8  *)(&(s_WifiPacketCfg.rxPack.cmd)), s_WifiPacketCfg.rxC
             -nt+3, ' ', true);
 265   4            }
 266   3            s_WifiPacketCfg.rxStatus = RX_IDDLE;
 267   3            s_WifiPacketCfg.rxCnt = 0;
 268   3            break;
 269   3          }
 270   2          default:
 271   2          {
 272   3            s_WifiPacketCfg.rxStatus = RX_IDDLE;
 273   3            s_WifiPacketCfg.rxCnt = 0;
 274   3            break;
 275   3          }
 276   2        } 
 277   1      }
 278          
 279          /*****************************************************************************
 280          函数名称 : data_handle
 281          功能描述 : 数据帧处理
 282          输入参数 : offset:数据起始位
 283          返回参数 : 无
 284          *****************************************************************************/
 285          void WifiPacketHandle(void)
 286          {
 287   1      #ifdef SUPPORT_MCU_FIRM_UPDATE
                unsigned char *firmware_addr;
                static unsigned long firm_length;                                             //MCU升级文件长度
                static unsigned char firm_update_flag;                                        //MCU升级标志
                unsigned long dp_len;
              #else
 293   1      //  unsigned short dp_len;
 294   1      #endif
 295   1        
 296   1        //unsigned char ret;
 297   1        //unsigned short i,total_len;
 298   1      #ifdef WIFI_TEST_ENABLE
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 6   

                //unsigned char result;
                //unsigned char rssi;
              #endif
 302   1        
 303   1        switch(s_WifiPacketCfg.rxPack.cmd)
 304   1        {
 305   2        case HEAT_BEAT_CMD:                                   //心跳包
 306   2        HeatBeatCheck();
 307   2        SendTxPacketData(HEAT_BEAT_CMD);
 308   2          break;
 309   2       
 310   2        case PRODUCT_INFO_CMD:                                //产品信息
 311   2          ProductInfoUpdate();
 312   2          SendTxPacketData(PRODUCT_INFO_CMD);
 313   2          break;
 314   2       
 315   2        case WORK_MODE_CMD:                                   //查询MCU设定的模块工作模式
 316   2          SendTxPacketData(WORK_MODE_CMD);
 317   2          break;
 318   2       
 319   2        case WIFI_STATE_CMD:                                  //wifi工作状态  
 320   2          s_Wifi.CurrState = s_WifiPacketCfg.rxPack.dat[0];
 321   2          SendTxPacketData(WIFI_STATE_CMD);
 322   2          break;
 323   2      
 324   2        case WIFI_RESET_CMD:                                  //重置wifi(wifi返回成功)
 325   2          s_Wifi.resetFlag = RESET_WIFI_SUCCESS;
 326   2          break;
 327   2         
 328   2        case WIFI_MODE_CMD:                                   //选择smartconfig/AP模式(wifi返回成功)  
 329   2          s_Wifi.setModeFlag = SET_WIFICONFIG_SUCCESS;
 330   2          break;
 331   2      
 332   2        case DATA_QUERT_CMD:                                  //命令下发
 333   2        AllDataPointHand();
 334   2        AllDataUpdate();
 335   2        SendTxPacketData(STATE_UPLOAD_CMD);
 336   2          break;
 337   2      
 338   2        case STATE_QUERY_CMD:                                 //状态查询
 339   2          AllDataUpdate();
 340   2        SendTxPacketData(STATE_UPLOAD_CMD);
 341   2          break;
 342   2       #if 0  
              #ifdef SUPPORT_MCU_FIRM_UPDATE
                case UPDATE_START_CMD:                                //升级开始
                  firm_length = wifi_uart_rx_buf[offset + DATA_START];
                  firm_length <<= 8;
                  firm_length |= wifi_uart_rx_buf[offset + DATA_START + 1];
                  firm_length <<= 8;
                  firm_length |= wifi_uart_rx_buf[offset + DATA_START + 2];
                  firm_length <<= 8;
                  firm_length |= wifi_uart_rx_buf[offset + DATA_START + 3];
                  //
                  wifi_uart_write_frame(UPDATE_START_CMD,0);
                  firm_update_flag = UPDATE_START_CMD;
                   break;
                  
                case UPDATE_TRANS_CMD:                                //升级传输
                  if(firm_update_flag == UPDATE_START_CMD)
                  {
                    //停止一切数据上报
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 7   

                    stop_update_flag = ENABLE;                                                 
                    
                    total_len = wifi_uart_rx_buf[offset + LENGTH_HIGH] * 0x100;
                    total_len += wifi_uart_rx_buf[offset + LENGTH_LOW];
                    
                    dp_len = wifi_uart_rx_buf[offset + DATA_START];
                    dp_len <<= 8;
                    dp_len |= wifi_uart_rx_buf[offset + DATA_START + 1];
                    dp_len <<= 8;
                    dp_len |= wifi_uart_rx_buf[offset + DATA_START + 2];
                    dp_len <<= 8;
                    dp_len |= wifi_uart_rx_buf[offset + DATA_START + 3];
                    
                    firmware_addr = (unsigned char *)wifi_uart_rx_buf;
                    firmware_addr += (offset + DATA_START + 4);
                    if((total_len == 4) && (dp_len == firm_length))
                    {
                      //最后一包
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,0);
                      
                      firm_update_flag = 0;
                    }
                    else if((total_len - 4) <= FIRM_UPDATA_SIZE)
                    {
                      ret = mcu_firm_update_handle(firmware_addr,dp_len,total_len - 4);
                    }
                    else
                    {
                      firm_update_flag = 0;
                      ret = ERROR;
                    }
                    
                    if(ret == SUCCESS)
                    {
                      wifi_uart_write_frame(UPDATE_TRANS_CMD,0);
                    }
                    //恢复一切数据上报
                    stop_update_flag = DISABLE;    
                  }
                  break;
              #endif      
                  
              #ifdef SUPPORT_MCU_RTC_CHECK
                case GET_LOCAL_TIME_CMD:                             //获取本地时间
                    mcu_write_rtctime(wifi_uart_rx_buf + offset + DATA_START);
                  break;
              #endif
               
              #ifdef WIFI_TEST_ENABLE
                case WIFI_TEST_CMD:                                   //wifi功能测试
                  result = wifi_uart_rx_buf[offset + DATA_START];
                  rssi = wifi_uart_rx_buf[offset + DATA_START + 1];
                  wifi_test_result(result, rssi);
                  break;
              #endif
              #endif 
 417   2        default:
 418   2          break;
 419   2       }
 420   1      }
 421          static void HeatBeatCheck(void)
 422          {
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 8   

 423   1        uint8 XDATA length = 1;
 424   1        static uint8 XDATA resetState = FALSE;
 425   1        
 426   1        if(FALSE == resetState)
 427   1        {
 428   2          SetTxPacketData(&resetState, length);
 429   2          resetState = TRUE;
 430   2        }
 431   1        else
 432   1        {
 433   2          SetTxPacketData(&resetState, length);
 434   2        }
 435   1      }
 436          static void ProductInfoUpdate(void)
 437          {
 438   1        SetTxPacketData((uint8 const* const)(PRODUCT_INFO), my_strlen((uint8 *)PRODUCT_INFO));
 439   1      }
 440          static void AllDataPointHand(void)
 441          { 
 442   1        uint8 i;
 443   1        uint8 dplength;
 444   1        for(i = 0; i < s_WifiPacketCfg.rxCnt; i++)
 445   1        {
 446   2          dplength = s_WifiPacketCfg.rxPack.dat[i+2]<<8;
 447   2          dplength |= s_WifiPacketCfg.rxPack.dat[i+3];
 448   2          OneDataPointHand(s_WifiPacketCfg.rxPack.dat);
 449   2          i += (dplength + 4);
 450   2        }
 451   1      }
 452          static uint8 OneDataPointHand(uint8 const XDATA* pDPVal)
 453          {
 454   1        uint8 XDATA dpID;
 455   1        uint8 XDATA dpIndex;
 456   1        uint8 XDATA dpType;
 457   1        uint16 XDATA dpLength;
 458   1        uint8 const XDATA* pVal;
 459   1        uint8 XDATA ret = FALSE;
 460   1        if(!pDPVal)
 461   1        {
 462   2          return ret;
 463   2        }
 464   1        dpID = pDPVal[0];
 465   1        dpType = pDPVal[1];
 466   1        dpLength = BUILD_UINT16(pDPVal[3], pDPVal[2]);
 467   1        pVal = pDPVal + 4;
 468   1        dpIndex = GetDowmloadDataPointIdIndex(dpID);
 469   1        if(s_DownloadCmd[dpIndex].dp_type == dpType)
 470   1        {
 471   2          return DownloadDataPointHandle(pVal, dpID, dpLength);
 472   2        }
 473   1        return ret;
 474   1      }
 475          
 476          
 477          static void BoolDataPointUpdate(uint8 XDATA *const pbuffer, uint8 XDATA dpid, uint8 XDATA value)
 478          {
 479   1        if(!pbuffer)
 480   1        {
 481   2          return ;
 482   2        }
 483   1        pbuffer[0] = dpid;
 484   1        pbuffer[1] = DP_TYPE_BOOL;
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 9   

 485   1        pbuffer[2] = 0x00;
 486   1        pbuffer[3] = 0x01;
 487   1        pbuffer[4] = value ? 1 : 0;
 488   1      }
 489          static void AllDataUpdate(void)
 490          {
 491   1        uint8 XDATA buffer[10];
 492   1        uint8 XDATA length = 0;
 493   1        if(g_RunState[0].BitState.opened) 
 494   1        {
 495   2          BoolDataPointUpdate(buffer, DPID_SWITCH_1, 1);
 496   2          length = 5;
 497   2        }
 498   1        if(g_RunState[0].BitState.closed) 
 499   1        {
 500   2          BoolDataPointUpdate(buffer, DPID_SWITCH_1, 0);
 501   2          length = 5;
 502   2        }
 503   1        BoolDataPointUpdate(buffer+length, DPID_SWITCH_2, 0);
 504   1        length += 5;
 505   1        SetTxPacketData(buffer, length);
 506   1      }
 507          
 508          static void SetTxPacketData(uint8 const* const src, uint8 XDATA length)
 509          {
 510   1        my_memcpy(&s_WifiPacketCfg.txPack.dat, src, length);
 511   1        s_WifiPacketCfg.txLength = length;
 512   1      }
 513          
 514          static void SendTxPacketData(uint8 XDATA cmd)
 515          {
 516   1        uint8 XDATA txLength = s_WifiPacketCfg.txLength+6;
 517   1        s_WifiPacketCfg.txPack.cmd = cmd;
 518   1        s_WifiPacketCfg.txPack.length[0] = HI_UINT16(s_WifiPacketCfg.txLength);
 519   1        s_WifiPacketCfg.txPack.length[1] = LO_UINT16(s_WifiPacketCfg.txLength);
 520   1        s_WifiPacketCfg.txPack.dat[s_WifiPacketCfg.txLength] = getCheckSum((uint8 const *)&s_WifiPacketCfg.txPack
             -.head_0, txLength++);
 521   1        UartSendBuffer(UART_WIFI, (const uint8 *const)&s_WifiPacketCfg.txPack.head_0, txLength);
 522   1      //  UartSendHexBuffer(UART_WIFI, "res:", (const uint8 *const)&s_WifiPacketCfg.txPack.head_0, txLength, ' ',
             - true);
 523   1      
 524   1        s_WifiPacketCfg.txLength = 0;
 525   1      }
 526          
 527          void WifiHandle(const MSG_t *const pMsg)
 528          {
 529   1        switch (pMsg->Param)
 530   1        {
 531   2          case WIFI_RESET:      //Wifi reset
 532   2            Log("WIFI_RESET\r\n");
 533   2            s_Wifi.resetFlag = RESET_WIFI_ERROR;
 534   2            SetTxPacketData(null, 0);
 535   2            SendTxPacketData(WIFI_RESET_CMD);
 536   2            break;
 537   2          case WIFI_SMART_CONFIG:   //Wifi smartconfig
 538   2            Log("WIFI_SMART_CONFIG\r\n");
 539   2            {
 540   3              uint8 XDATA dat = 0x00;
 541   3              s_Wifi.CurrState = SMART_CONFIG_STATE;
 542   3              s_Wifi.setModeFlag = RESET_WIFI_ERROR;
 543   3              SetTxPacketData(&dat, 1);
 544   3              SendTxPacketData(WIFI_MODE_CMD);
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 10  

 545   3            }
 546   2            break;
 547   2          case WIFI_AP:       //Wifi ap
 548   2            Log("WIFI_AP\r\n");
 549   2            {
 550   3              uint8 XDATA dat = 0x01;
 551   3              s_Wifi.CurrState = AP_STATE;
 552   3              s_Wifi.setModeFlag = RESET_WIFI_ERROR;
 553   3              SetTxPacketData(&dat, 1);
 554   3              SendTxPacketData(WIFI_MODE_CMD);
 555   3            }
 556   2            break;
 557   2          case WIFI_UPLOAD:
 558   2            Log("WIFI_UPLOAD\r\n");
 559   2            {
 560   3              AllDataUpdate();
 561   3              SendTxPacketData(STATE_UPLOAD_CMD);
 562   3            }
 563   2            break;
 564   2          default:
 565   2            break;
 566   2        }     
 567   1      }
 568          
 569          void WifiStatusShow(void)
 570          {
 571   1        if(s_Wifi.CurrState != s_Wifi.BackState)
 572   1        {
 573   2          s_Wifi.BackState = s_Wifi.CurrState;
 574   2          switch (s_Wifi.CurrState)
 575   2          {
 576   3            case SMART_CONFIG_STATE:
 577   3              Log("SMART_CONFIG_STATE\r\n");
 578   3              LedSetFlash(LED_WIFI_ID, LED_FLASH_ALWAYS, 2, 2);
 579   3              break;
 580   3            case AP_STATE:
 581   3              Log("AP_STATE\r\n");
 582   3              LedSetFlash(LED_WIFI_ID, LED_FLASH_ALWAYS, 10, 10);
 583   3              break;
 584   3            case WIFI_NOT_CONNECTED:
 585   3              Log("WIFI_NOT_CONNECTED\r\n");
 586   3              LedSetLevel(LED_WIFI_ID, ON, true);
 587   3              break;
 588   3              
 589   3            case WIFI_CONNECTED:
 590   3              Log("WIFI_CONNECTED\r\n");
 591   3              LedSetLevel(LED_WIFI_ID, OFF, true);
 592   3              break;
 593   3      
 594   3            default:
 595   3              break;
 596   3          }
 597   2        }
 598   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1414    ----
   CONSTANT SIZE    =    149    ----
   XDATA SIZE       =     77      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
C51 COMPILER V9.52.0.0   WIFI                                                              07/10/2018 10:50:11 PAGE 11  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
